[
  {
    "key": "tdd",
    "title": "Test-Driven Development (TDD)",
    "category": "engineering",
    "severity": "gate",
    "description": "Enforce test-driven development so behavior changes are specified by failing tests before implementation, preventing untested code from entering the codebase.",
    "rules": {
      "hard": [
        "No behavior-changing code may be committed without a prior commit containing a failing test that passes after the change",
        "Pure refactors must not break any existing tests",
        "All new public functions/classes must have at least one example-based test"
      ],
      "soft": [
        "Target â‰¥80% line coverage on new/changed code",
        "Prefer fast unit tests over slow integration tests"
      ]
    },
    "conflicts": [
      "exploratory-spike"
    ],
    "implies": [
      "code-review"
    ]
  },
  {
    "key": "security",
    "title": "Security & Supply Chain",
    "category": "security",
    "severity": "gate",
    "description": "Force systematic security hygiene to prevent common vulnerability classes and insecure defaults during development. Establish a zero-trust environment.",
    "rules": {
      "hard": [
        "Never hardcode secrets, tokens, or credentials",
        "All external inputs must be validated and escaped/parameterized before use in queries, commands, or HTML",
        "Dependency updates must pass automated vulnerability scans before merge"
      ],
      "soft": [
        "Apply principle of least privilege to all permissions and access controls",
        "Enable and configure secure headers (CSP, HSTS, etc.) by default"
      ]
    },
    "conflicts": [],
    "implies": [
      "code-review"
    ]
  },
  {
    "key": "refactoring",
    "title": "Refactoring & Code Quality",
    "category": "engineering",
    "severity": "standard",
    "description": "Govern safe refactoring to improve code structure without altering behavior, ensuring changes remain verifiable and low-risk through existing tests.",
    "rules": {
      "hard": [
        "Refactoring commits must not add or change external behavior",
        "All existing tests must remain green throughout the process",
        "Refactors must be performed in small, atomic commits"
      ],
      "soft": [
        "Reduce cyclomatic complexity where >10",
        "Eliminate duplicated code blocks >20 lines"
      ]
    },
    "conflicts": [],
    "implies": []
  },
  {
    "key": "performance",
    "title": "Performance & Optimization",
    "category": "engineering",
    "severity": "standard",
    "description": "Prevent silent performance regressions and unmeasured optimization claims by requiring measurement and bounded work in performance-sensitive paths.",
    "rules": {
      "hard": [
        "No performance-sensitive change without before/after measurement",
        "No unbounded loops or queries in hot paths without explicit limits",
        "No caching without an invalidation strategy"
      ],
      "soft": [
        "Prefer simpler algorithms over clever micro-optimizations",
        "Optimize only measured bottlenecks, not assumptions"
      ]
    },
    "conflicts": [],
    "implies": []
  },
  {
    "key": "documentation",
    "title": "Documentation & Knowledge Management",
    "category": "process",
    "severity": "standard",
    "description": "Ensure knowledge survives beyond the current session by requiring accurate documentation for public behavior, architecture, and decisions.",
    "rules": {
      "hard": [
        "Public APIs must be documented (usage + edge cases)",
        "Architecture decisions must be recorded (ADRs or equivalent)",
        "Docs must be updated alongside behavior changes"
      ],
      "soft": [
        "Prefer examples over prose",
        "Keep docs close to code (docs/ near relevant modules)"
      ]
    },
    "conflicts": [],
    "implies": []
  },
  {
    "key": "ops-production-safety",
    "title": "Operations & Production Safety",
    "category": "operations",
    "severity": "gate",
    "description": "Prevent changes that work locally but fail in production by enforcing rollout, rollback, observability, and environment awareness.",
    "rules": {
      "hard": [
        "Every production change must have an explicit rollback plan",
        "New production-impacting behavior must emit logs/metrics",
        "Config changes must be explicit, reviewable, and environment-aware"
      ],
      "soft": [
        "Prefer feature flags for risky changes",
        "Deploy incrementally (canary/gradual rollout) where possible"
      ]
    },
    "conflicts": [],
    "implies": [
      "security"
    ]
  },
  {
    "key": "legacy-migration",
    "title": "Legacy Migration & Modernization",
    "category": "engineering",
    "severity": "standard",
    "description": "Enable controlled modernization of legacy systems while preventing accidental rewrites and containing risk through incremental, reversible steps.",
    "rules": {
      "hard": [
        "No migration work without an explicit exit plan",
        "New code must not increase the legacy surface area",
        "Migration must be incremental and reversible"
      ],
      "soft": [
        "Prefer strangler patterns over rewrites",
        "Wrap legacy boundaries before refactoring internals"
      ]
    },
    "conflicts": [
      "refactoring"
    ],
    "implies": []
  },
  {
    "key": "exploratory-spike",
    "title": "Exploratory / Spike Mode",
    "category": "process",
    "severity": "mode",
    "description": "Allow rapid learning and experimentation without polluting production code, by enforcing strict deletion and promotion rules.",
    "rules": {
      "hard": [
        "Spike code must be isolated and deletable",
        "No spike merges without an explicit promotion decision",
        "Spikes must be labeled and time-boxed"
      ],
      "soft": [
        "Prefer throwaway branches or sandbox folders",
        "Capture learnings in notes/docs before deleting"
      ]
    },
    "conflicts": [
      "tdd",
      "security",
      "ops-production-safety"
    ],
    "implies": []
  },
  {
    "key": "code-review",
    "title": "Code Review & Quality Gates",
    "category": "process",
    "severity": "gate",
    "description": "Ensure consistent, high-quality code review practices that catch defects early and maintain architectural integrity.",
    "rules": {
      "hard": [
        "All code must be reviewed by at least one other person before merge",
        "PRs must pass all automated checks (tests, linting, security scans)",
        "Breaking changes require explicit approval from tech lead or architect"
      ],
      "soft": [
        "Reviewers should focus on logic, architecture, and maintainability, not just style",
        "Provide constructive feedback with specific suggestions"
      ]
    },
    "conflicts": [],
    "implies": []
  },
  {
    "key": "api-design",
    "title": "API Design & Contracts",
    "category": "architecture",
    "severity": "gate",
    "description": "Enforce consistent, well-designed APIs that are easy to use, hard to misuse, and maintain backward compatibility.",
    "rules": {
      "hard": [
        "Breaking API changes require a new version (v2, v3, etc.)",
        "All public APIs must have OpenAPI/Swagger documentation",
        "API responses must use consistent error format with clear messages"
      ],
      "soft": [
        "Use RESTful conventions unless there's a compelling reason not to",
        "Prefer POST for operations with side effects, GET for reads"
      ]
    },
    "conflicts": [],
    "implies": [
      "documentation"
    ]
  },
  {
    "key": "database-data-integrity",
    "title": "Database & Data Integrity",
    "category": "operations",
    "severity": "gate",
    "description": "Ensure data consistency, prevent data loss, and maintain database performance through disciplined schema and query practices.",
    "rules": {
      "hard": [
        "All schema changes must be reversible migrations with down scripts",
        "No direct database modifications in production; use migrations only",
        "All data-modifying operations must be wrapped in transactions"
      ],
      "soft": [
        "Use database constraints (NOT NULL, CHECK, UNIQUE) to enforce business rules",
        "Avoid SELECT * in production code; specify columns explicitly"
      ]
    },
    "conflicts": [],
    "implies": []
  },
  {
    "key": "frontend-ux",
    "title": "Frontend & User Experience",
    "category": "engineering",
    "severity": "standard",
    "description": "Ensure consistent, accessible, and performant user interfaces that provide excellent user experience across devices and capabilities.",
    "rules": {
      "hard": [
        "All interactive elements must be keyboard accessible",
        "All images must have alt text",
        "Color cannot be the only means of conveying information"
      ],
      "soft": [
        "Target Lighthouse score >90 for performance and accessibility",
        "Implement loading states for async operations >300ms"
      ]
    },
    "conflicts": [],
    "implies": []
  }
]
